import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { ReportData, PDFExportOptions } from './types';
import { formatDate, formatNumber, formatPercentage } from './report-data';
// Chart generation imports moved to dynamic imports to avoid Next.js client-side build issues
// import {
//   generateRequestStatusPieChart,
//   generateDepartmentBarChart,
//   generateEmployeePerformanceChart,
//   generateSummaryChart,
//   OMNIA_COLORS,
//   getChartLabels
// } from './chart-generator';
// Logo utilities removed - using only company name

// Extend jsPDF type to include autoTable
declare module 'jspdf' {
  interface jsPDF {
    autoTable: (options: any) => void;
  }
}

// PDF Layout constants
const PDF_CONFIG = {
  margins: {
    top: 20,
    right: 20,
    bottom: 20,
    left: 20
  },
  headerHeight: 50,
  footerHeight: 15,
  logoMaxWidth: 100,
  logoMaxHeight: 40,
  titleFontSize: 20,
  subtitleFontSize: 14,
  bodyFontSize: 10,
  smallFontSize: 8,
  colors: {
    primary: '#3B82F6',
    secondary: '#10B981',
    accent: '#F59E0B',
    danger: '#EF4444',
    text: '#1F2937',
    lightGray: '#F3F4F6',
    gray: '#6B7280'
  }
};

// Translation function for PDF content
function getTranslations(language: 'it' | 'en' | 'es' = 'it') {
  const translations = {
    it: {
      reportTitle: 'Report Analisi Ferie',
      periodLabel: 'Periodo di Riferimento:',
      generatedOn: 'Generato il:',
      generatedBy: 'Generato da:',
      page: 'Pagina',
      of: 'di',

      // Executive Summary
      executiveSummary: 'Riepilogo Esecutivo',
      keyMetrics: 'Metriche Chiave',
      totalEmployees: 'Dipendenti Totali',
      activeEmployees: 'Dipendenti Attivi',
      utilizationRate: 'Tasso di Utilizzo',
      approvalRate: 'Tasso di Approvazione',
      availableDays: 'Giorni Disponibili',
      usedDays: 'Giorni Utilizzati',
      pendingRequests: 'Richieste Pendenti',

      // Charts
      requestStatusChart: 'Distribuzione Stato Richieste',
      departmentChart: 'Utilizzo Ferie per Dipartimento',
      performanceChart: 'Performance Top 10 Dipendenti',

      // Tables
      employeePerformance: 'Performance Dipendenti',
      departmentAnalysis: 'Analisi per Dipartimento',
      employee: 'Dipendente',
      department: 'Dipartimento',
      status: 'Stato',
      requests: 'Richieste',
      utilization: 'Utilizzo',
      days: 'Giorni',

      // Footer
      confidential: 'Documento Confidenziale - Solo per uso interno',
      signature: 'Firma Digitale Amministratore'
    },
    en: {
      reportTitle: 'Holiday Analysis Report',
      periodLabel: 'Reference Period:',
      generatedOn: 'Generated on:',
      generatedBy: 'Generated by:',
      page: 'Page',
      of: 'of',

      // Executive Summary
      executiveSummary: 'Executive Summary',
      keyMetrics: 'Key Metrics',
      totalEmployees: 'Total Employees',
      activeEmployees: 'Active Employees',
      utilizationRate: 'Utilization Rate',
      approvalRate: 'Approval Rate',
      availableDays: 'Available Days',
      usedDays: 'Used Days',
      pendingRequests: 'Pending Requests',

      // Charts
      requestStatusChart: 'Request Status Distribution',
      departmentChart: 'Holiday Utilization by Department',
      performanceChart: 'Top 10 Employee Performance',

      // Tables
      employeePerformance: 'Employee Performance',
      departmentAnalysis: 'Department Analysis',
      employee: 'Employee',
      department: 'Department',
      status: 'Status',
      requests: 'Requests',
      utilization: 'Utilization',
      days: 'Days',

      // Footer
      confidential: 'Confidential Document - Internal Use Only',
      signature: 'Administrator Digital Signature'
    },
    es: {
      reportTitle: 'Informe de Análisis de Vacaciones',
      periodLabel: 'Período de Referencia:',
      generatedOn: 'Generado el:',
      generatedBy: 'Generado por:',
      page: 'Página',
      of: 'de',

      // Executive Summary
      executiveSummary: 'Resumen Ejecutivo',
      keyMetrics: 'Métricas Clave',
      totalEmployees: 'Empleados Totales',
      activeEmployees: 'Empleados Activos',
      utilizationRate: 'Tasa de Utilización',
      approvalRate: 'Tasa de Aprobación',
      availableDays: 'Días Disponibles',
      usedDays: 'Días Utilizados',
      pendingRequests: 'Solicitudes Pendientes',

      // Charts
      requestStatusChart: 'Distribución Estado de Solicitudes',
      departmentChart: 'Utilización de Vacaciones por Departamento',
      performanceChart: 'Rendimiento Top 10 Empleados',

      // Tables
      employeePerformance: 'Rendimiento de Empleados',
      departmentAnalysis: 'Análisis por Departamento',
      employee: 'Empleado',
      department: 'Departamento',
      status: 'Estado',
      requests: 'Solicitudes',
      utilization: 'Utilización',
      days: 'Días',

      // Footer
      confidential: 'Documento Confidencial - Solo para Uso Interno',
      signature: 'Firma Digital del Administrador'
    }
  };

  return translations[language] || translations.it;
}

// Generate PDF Header with company branding
async function generatePDFHeader(
  doc: jsPDF,
  data: ReportData,
  options: PDFExportOptions
): Promise<void> {
  const t = getTranslations(data.metadata.language);
  const { companyName, companyLogo } = data.metadata;

  // Header background
  doc.setFillColor(245, 247, 250); // Light gray background
  doc.rect(0, 0, doc.internal.pageSize.width, PDF_CONFIG.headerHeight, 'F');

  let logoX = PDF_CONFIG.margins.left;
  let logoWidth = 0;

  // Add company logo if available
  if (companyLogo && companyLogo.includes('data:image/')) {
    try {
      // Check if the logo is SVG format (not supported by jsPDF)
      if (companyLogo.includes('data:image/svg+xml')) {
        console.log('SVG logo detected, skipping image - using company name only');
        logoWidth = 0; // No logo space needed
      } else {
        const optimizedLogo = companyLogo; // Use logo as-is for now

        // Calculate logo dimensions maintaining aspect ratio
        const img = new Image();
        await new Promise((resolve) => {
          img.onload = resolve;
          img.src = optimizedLogo;
        });

        const aspectRatio = img.width / img.height;
        logoWidth = Math.min(PDF_CONFIG.logoMaxWidth, PDF_CONFIG.logoMaxHeight * aspectRatio);
        const logoHeight = logoWidth / aspectRatio;

        doc.addImage(
          optimizedLogo,
          'PNG',
          logoX,
          PDF_CONFIG.margins.top - 5,
          logoWidth,
          logoHeight
        );
      }
    } catch (error) {
      console.warn('Failed to add logo to PDF:', error);
      logoWidth = 0; // No logo space if failed
    }
  } else {
    console.log('No valid logo found, using company name only');
    logoWidth = 0; // No logo space needed
  }

  // Company name and report title
  const textX = logoX + logoWidth + 10;
  const pageWidth = doc.internal.pageSize.width;

  // Company name
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(PDF_CONFIG.subtitleFontSize);
  doc.setTextColor(PDF_CONFIG.colors.text);
  doc.text(companyName || 'Company Name', textX, PDF_CONFIG.margins.top + 5);

  // Report title
  doc.setFontSize(PDF_CONFIG.titleFontSize);
  doc.setTextColor(PDF_CONFIG.colors.primary);
  doc.text(t.reportTitle, textX, PDF_CONFIG.margins.top + 20);

  // Period and generation info on the right
  const rightMargin = pageWidth - PDF_CONFIG.margins.right;
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(PDF_CONFIG.bodyFontSize);
  doc.setTextColor(PDF_CONFIG.colors.gray);

  const periodText = `${t.periodLabel} ${data.period.label}`;
  const generatedText = `${t.generatedOn} ${formatDate(data.metadata.generatedAt, data.metadata.language)}`;
  const byText = `${t.generatedBy} ${data.metadata.generatedBy.name}`;

  // Right-align text
  doc.text(periodText, rightMargin, PDF_CONFIG.margins.top + 5, { align: 'right' });
  doc.text(generatedText, rightMargin, PDF_CONFIG.margins.top + 15, { align: 'right' });
  doc.text(byText, rightMargin, PDF_CONFIG.margins.top + 25, { align: 'right' });

  // Header separator line
  doc.setDrawColor(PDF_CONFIG.colors.gray);
  doc.setLineWidth(0.5);
  doc.line(PDF_CONFIG.margins.left, PDF_CONFIG.headerHeight, pageWidth - PDF_CONFIG.margins.right, PDF_CONFIG.headerHeight);
}

// Generate PDF Footer
function generatePDFFooter(doc: jsPDF, data: ReportData, currentPage: number, totalPages: number): void {
  const t = getTranslations(data.metadata.language);
  const pageHeight = doc.internal.pageSize.height;
  const pageWidth = doc.internal.pageSize.width;
  const footerY = pageHeight - PDF_CONFIG.footerHeight;

  // Footer separator line
  doc.setDrawColor(PDF_CONFIG.colors.gray);
  doc.setLineWidth(0.5);
  doc.line(PDF_CONFIG.margins.left, footerY - 5, pageWidth - PDF_CONFIG.margins.right, footerY - 5);

  // Footer content
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(PDF_CONFIG.smallFontSize);
  doc.setTextColor(PDF_CONFIG.colors.gray);

  // Left: Confidential notice
  doc.text(t.confidential, PDF_CONFIG.margins.left, footerY);

  // Center: Company name and signature
  const centerX = pageWidth / 2;
  doc.text(t.signature, centerX, footerY, { align: 'center' });

  // Right: Page numbers
  const pageText = `${t.page} ${currentPage} ${t.of} ${totalPages}`;
  doc.text(pageText, pageWidth - PDF_CONFIG.margins.right, footerY, { align: 'right' });
}

// Generate Executive Summary section
function generateExecutiveSummary(doc: jsPDF, data: ReportData, startY: number): number {
  const t = getTranslations(data.metadata.language);
  let currentY = startY + 20;

  // Section title
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(PDF_CONFIG.subtitleFontSize);
  doc.setTextColor(PDF_CONFIG.colors.primary);
  doc.text(t.executiveSummary, PDF_CONFIG.margins.left, currentY);
  currentY += 15;

  // Key metrics grid
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(PDF_CONFIG.bodyFontSize);
  doc.setTextColor(PDF_CONFIG.colors.text);
  doc.text(t.keyMetrics, PDF_CONFIG.margins.left, currentY);
  currentY += 10;

  const stats = data.statistics;
  const pageWidth = doc.internal.pageSize.width;
  const cardWidth = (pageWidth - PDF_CONFIG.margins.left - PDF_CONFIG.margins.right - 30) / 3;

  // Create metric cards
  const metrics = [
    { label: t.totalEmployees, value: stats.totalEmployees.toString(), color: PDF_CONFIG.colors.primary },
    { label: t.utilizationRate, value: formatPercentage(stats.utilizationRate), color: PDF_CONFIG.colors.secondary },
    { label: t.approvalRate, value: formatPercentage(stats.approvalRate), color: PDF_CONFIG.colors.accent }
  ];

  let cardX = PDF_CONFIG.margins.left;

  metrics.forEach((metric, index) => {
    // Card background
    doc.setFillColor(250, 250, 250);
    doc.roundedRect(cardX, currentY, cardWidth, 25, 3, 3, 'F');

    // Metric value
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(16);
    doc.setTextColor(metric.color);
    doc.text(metric.value, cardX + cardWidth/2, currentY + 10, { align: 'center' });

    // Metric label
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(PDF_CONFIG.smallFontSize);
    doc.setTextColor(PDF_CONFIG.colors.gray);
    doc.text(metric.label, cardX + cardWidth/2, currentY + 20, { align: 'center' });

    cardX += cardWidth + 15;
  });

  return currentY + 35;
}

// Generate simple chart placeholder (since complex charts need canvas)
function generateSimpleChart(
  doc: jsPDF,
  title: string,
  data: any[],
  x: number,
  y: number,
  width: number,
  height: number
): void {
  // Chart border
  doc.setDrawColor(PDF_CONFIG.colors.gray);
  doc.rect(x, y, width, height);

  // Chart title
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(PDF_CONFIG.bodyFontSize);
  doc.setTextColor(PDF_CONFIG.colors.text);
  doc.text(title, x + width/2, y - 5, { align: 'center' });

  // Simple bar representation for data
  if (data.length > 0) {
    const barWidth = (width - 20) / data.length;
    const maxValue = Math.max(...data.map(d => d.value || d.utilizationRate || 0));

    data.forEach((item, index) => {
      const value = item.value || item.utilizationRate || 0;
      const barHeight = (value / maxValue) * (height - 30);
      const barX = x + 10 + (index * barWidth);
      const barY = y + height - 15 - barHeight;

      // Bar - using local color instead of OMNIA_COLORS
      doc.setFillColor(59, 130, 246); // Primary blue color
      doc.rect(barX, barY, barWidth - 2, barHeight, 'F');

      // Label
      doc.setFontSize(6);
      doc.setTextColor(PDF_CONFIG.colors.gray);
      const label = item.name || item.department || '';
      if (label.length > 10) {
        doc.text(label.substring(0, 8) + '...', barX + barWidth/2, y + height - 5, { align: 'center' });
      } else {
        doc.text(label, barX + barWidth/2, y + height - 5, { align: 'center' });
      }
    });
  }
}

// Generate charts section
function generateChartsSection(doc: jsPDF, data: ReportData, startY: number): number {
  const t = getTranslations(data.metadata.language);
  let currentY = startY;

  // Charts section
  const pageWidth = doc.internal.pageSize.width;
  const chartWidth = (pageWidth - PDF_CONFIG.margins.left - PDF_CONFIG.margins.right - 20) / 2;
  const chartHeight = 80;

  // Generate simplified department data for basic chart
  const deptData = data.departmentStats.map(dept => ({
    name: dept.name,
    utilizationRate: dept.utilizationRate
  }));

  generateSimpleChart(
    doc,
    t.departmentChart,
    deptData.slice(0, 5),
    PDF_CONFIG.margins.left,
    currentY,
    chartWidth,
    chartHeight
  );

  // Generate simplified employee performance data for basic chart
  const performanceData = data.employeePerformance.map(emp => ({
    name: emp.name,
    value: emp.utilizationRate
  }));

  generateSimpleChart(
    doc,
    t.performanceChart,
    performanceData.slice(0, 5),
    PDF_CONFIG.margins.left + chartWidth + 20,
    currentY,
    chartWidth,
    chartHeight
  );

  return currentY + chartHeight + 20;
}

// Generate tables section
function generateTablesSection(doc: jsPDF, data: ReportData, startY: number): number {
  const t = getTranslations(data.metadata.language);
  let currentY = startY;

  // Employee Performance Table
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(PDF_CONFIG.subtitleFontSize);
  doc.setTextColor(PDF_CONFIG.colors.primary);
  doc.text(t.employeePerformance, PDF_CONFIG.margins.left, currentY);
  currentY += 10;

  // Prepare table data
  const employeeTableData = data.employeePerformance.slice(0, 10).map(emp => [
    emp.name,
    emp.departmentName || 'N/A',
    formatNumber(emp.holidaysUsed),
    formatNumber(emp.holidayAllowance),
    formatPercentage(emp.utilizationRate),
    emp.requestCount.toString()
  ]);

  autoTable(doc, {
    head: [[t.employee, t.department, t.usedDays, 'Totale', t.utilization, t.requests]],
    body: employeeTableData,
    startY: currentY,
    styles: {
      fontSize: PDF_CONFIG.smallFontSize,
      cellPadding: 2
    },
    headStyles: {
      fillColor: [59, 130, 246], // Primary color
      textColor: 255,
      fontStyle: 'bold'
    },
    alternateRowStyles: {
      fillColor: [245, 247, 250]
    },
    margin: {
      left: PDF_CONFIG.margins.left,
      right: PDF_CONFIG.margins.right
    }
  });

  // Update currentY after table
  currentY = (doc as any).lastAutoTable.finalY + 20;

  // Department Analysis Table
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(PDF_CONFIG.subtitleFontSize);
  doc.setTextColor(PDF_CONFIG.colors.primary);
  doc.text(t.departmentAnalysis, PDF_CONFIG.margins.left, currentY);
  currentY += 10;

  const deptTableData = data.departmentStats.map(dept => [
    dept.name,
    dept.employeeCount.toString(),
    formatNumber(dept.holidaysUsed),
    formatNumber(dept.holidaysAllowed),
    formatPercentage(dept.utilizationRate),
    dept.requests.toString()
  ]);

  autoTable(doc, {
    head: [[t.department, 'Dipendenti', t.usedDays, 'Totale', t.utilization, t.requests]],
    body: deptTableData,
    startY: currentY,
    styles: {
      fontSize: PDF_CONFIG.smallFontSize,
      cellPadding: 2
    },
    headStyles: {
      fillColor: [16, 185, 129], // Secondary color
      textColor: 255,
      fontStyle: 'bold'
    },
    alternateRowStyles: {
      fillColor: [245, 247, 250]
    },
    margin: {
      left: PDF_CONFIG.margins.left,
      right: PDF_CONFIG.margins.right
    }
  });

  return (doc as any).lastAutoTable.finalY + 20;
}

// Main PDF export function
export async function generatePDFReport(
  data: ReportData,
  options: PDFExportOptions
): Promise<Uint8Array> {
  console.log('🎯🎯🎯 PDF GENERATOR MAIN FUNCTION CALLED 🎯🎯🎯');
  console.log('PDF generation options:', {
    includeCharts: options.includeCharts,
    orientation: options.orientation,
    pageSize: options.pageSize,
    totalRequests: data.requests.length,
    periodType: data.period.type
  });

  // Use advanced PDF generator if charts are requested
  if (options.includeCharts) {
    console.log('📊📊📊 CHARTS REQUESTED - USING ADVANCED PDF GENERATOR 📊📊📊');
    try {
      // Check if we're in a browser environment
      if (typeof window !== 'undefined') {
        // Browser environment - use Netlify Function
        console.log('🌐🌐🌐 BROWSER ENVIRONMENT - CALLING NETLIFY FUNCTION 🌐🌐🌐');
        console.log('🌐🌐🌐 FUNCTION URL: /.netlify/functions/generate-advanced-pdf 🌐🌐🌐');
        console.log('🌐🌐🌐 REQUEST DATA SIZE:', JSON.stringify({ data, options }).length, 'bytes 🌐🌐🌐');

        let response;
        try {
          console.log('🌐🌐🌐 STARTING FETCH REQUEST... 🌐🌐🌐');
          response = await fetch('/.netlify/functions/generate-advanced-pdf', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ data, options })
          });
          console.log('🌐🌐🌐 FETCH REQUEST COMPLETED! 🌐🌐🌐');
        } catch (fetchError) {
          console.error('🚨🚨🚨 FETCH REQUEST FAILED:', fetchError, '🚨🚨🚨');
          throw fetchError;
        }

        console.log('🌐🌐🌐 NETLIFY FUNCTION RESPONSE STATUS:', response.status, '🌐🌐🌐');
        console.log('🌐🌐🌐 NETLIFY FUNCTION RESPONSE OK:', response.ok, '🌐🌐🌐');
        console.log('🌐🌐🌐 NETLIFY FUNCTION RESPONSE HEADERS:', Array.from(response.headers.entries()), '🌐🌐🌐');

        if (response.ok) {
          console.log('✅✅✅ NETLIFY FUNCTION SUCCESS - PARSING RESPONSE ✅✅✅');
          let result;
          try {
            result = await response.json();
            console.log('✅✅✅ RESPONSE PARSED SUCCESSFULLY ✅✅✅');
            console.log('✅✅✅ RESPONSE KEYS:', Object.keys(result), '✅✅✅');
            console.log('✅✅✅ RESPONSE SUCCESS:', result.success, '✅✅✅');
          } catch (parseError) {
            console.error('❌❌❌ FAILED TO PARSE JSON RESPONSE:', parseError, '❌❌❌');
            const textResponse = await response.text();
            console.error('❌❌❌ RESPONSE TEXT:', textResponse, '❌❌❌');
            throw parseError;
          }

          if (result.success && result.pdf) {
            console.log('✅✅✅ PDF RECEIVED FROM NETLIFY FUNCTION ✅✅✅');
            console.log('✅✅✅ PDF BASE64 LENGTH:', result.pdf.length, 'chars ✅✅✅');
            // Convert base64 back to Uint8Array
            const binaryString = atob(result.pdf);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
            console.log('✅✅✅ PDF CONVERTED TO BYTES - SIZE:', bytes.length, 'bytes ✅✅✅');
            return bytes;
          } else {
            console.error('❌❌❌ NETLIFY FUNCTION RESULT INVALID:', result, '❌❌❌');
            console.error('❌❌❌ RESULT SUCCESS:', result.success, '❌❌❌');
            console.error('❌❌❌ RESULT HAS PDF:', !!result.pdf, '❌❌❌');
          }
        } else {
          console.error('❌❌❌ NETLIFY FUNCTION FAILED:', response.status, response.statusText, '❌❌❌');
          try {
            const errorText = await response.text();
            console.error('❌❌❌ NETLIFY FUNCTION ERROR BODY:', errorText, '❌❌❌');
          } catch (e) {
            console.error('❌❌❌ COULD NOT READ ERROR BODY:', e, '❌❌❌');
          }
        }
        throw new Error(`Netlify Function failed: ${response.status} ${response.statusText}`);
      } else {
        // Server environment - use direct import
        console.log('🔥🔥🔥 PDF GENERATOR: About to import advanced PDF generator 🔥🔥🔥');
        const { generateAdvancedPDFReport } = await import('./advanced-pdf-generator');
        console.log('🔥🔥🔥 PDF GENERATOR: Advanced generator imported successfully 🔥🔥🔥');
        console.log('🔥🔥🔥 PDF GENERATOR: About to call generateAdvancedPDFReport 🔥🔥🔥');
        const result = await generateAdvancedPDFReport(data, options);
        console.log('🔥🔥🔥 PDF GENERATOR: Advanced PDF generated successfully! 🔥🔥🔥');
        return result;
      }
    } catch (error) {
      console.error('🚨🚨🚨 PDF GENERATOR: ADVANCED PDF FAILED 🚨🚨🚨');
      console.error('Error details:', error);
      console.error('Error message:', error instanceof Error ? error.message : 'Unknown error');
      console.error('Error stack:', error instanceof Error ? error.stack : 'No stack trace');
      console.warn('Advanced PDF generation failed, falling back to basic version:', error);
      // Continue with basic version as fallback
    }
  } else {
    console.log('📄📄📄 NO CHARTS REQUESTED - USING BASIC PDF GENERATOR 📄📄📄');
  }

  console.log('📝📝📝 PROCEEDING WITH BASIC PDF GENERATION 📝📝📝');
  const doc = new jsPDF({
    orientation: options.orientation || 'portrait',
    unit: 'pt',
    format: options.pageSize || 'a4'
  });

  let currentY = PDF_CONFIG.headerHeight + 10;

  try {
    // Generate header
    await generatePDFHeader(doc, data, options);

    // Add cover page if requested
    if (options.includeCoverPage) {
      // Cover page content here
      currentY += 50;
    }

    // Executive summary
    currentY = generateExecutiveSummary(doc, data, currentY);

    // Charts section (basic version)
    if (options.includeCharts) {
      currentY = generateChartsSection(doc, data, currentY);
    }

    // Check if we need a new page
    const pageHeight = doc.internal.pageSize.height;
    if (currentY > pageHeight - 150) {
      doc.addPage();
      currentY = PDF_CONFIG.headerHeight + 20;
    }

    // Tables section
    if (options.includeEmployeeDetails || options.includeDepartmentAnalysis) {
      currentY = generateTablesSection(doc, data, currentY);
    }

    // Add footer to all pages
    const pageCount = doc.internal.pages.length - 1;
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      generatePDFFooter(doc, data, i, pageCount);
    }

    return new Uint8Array(doc.output('arraybuffer') as ArrayBuffer);

  } catch (error) {
    console.error('Error generating PDF report:', error);
    throw new Error('Failed to generate PDF report');
  }
}

// Utility function to download PDF
export async function downloadPDFReport(
  data: ReportData,
  options: PDFExportOptions,
  filename?: string
): Promise<void> {
  try {
    const pdfBytes = await generatePDFReport(data, options);

    // Create blob and download
    const blob = new Blob([new Uint8Array(pdfBytes)], { type: 'application/pdf' });
    const url = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = url;
    link.download = filename || `holiday-report-${data.period.type}-${formatDate(data.metadata.generatedAt, data.metadata.language)}.pdf`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    URL.revokeObjectURL(url);
  } catch (error) {
    console.error('Error downloading PDF report:', error);
    throw error;
  }
}